from pathlib import Path
import sys

path = Path("src/App.tsx")
text = path.read_text(encoding="utf-8")
start = text.find("const selectedPlate = selectedPlateId")
if start == -1:
    print("start marker not found")
    sys.exit(1)
end_marker = "                    );\n                  })()"
end = text.find(end_marker, start)
if end == -1:
    print("end marker not found")
    sys.exit(1)
replacement = """const selectedPlate = selectedPlateId\n                      ? steelPlates.find(\n                          (p) => p.plateId === selectedPlateId,\n                        )\n                      : undefined;\n                    if (!selectedPlate) {\n                      return (\n                        <div className=\"absolute inset-0 flex items-center justify-center text-xs text-muted-foreground\">\n                          请选择左侧钢板以查看长带图像\n                        </div>\n                      );\n                    }\n                    if (!surfaceImageInfo || surfaceImageInfo.length === 0) {\n                      return (\n                        <div className=\"absolute inset-0 flex items-center justify-center text-xs text-muted-foreground\">\n                          当前钢板尚无图像元数据（surface_images 为空）\n                        </div>\n                      );\n                    }\n                    const seqNo = Number(selectedPlate.serialNumber);\n                    if (Number.isNaN(seqNo)) {\n                      return (\n                        <div className=\"absolute inset-0 flex items-center justify-center text-xs text-muted-foreground\">\n                          无法解析序列号，无法请求图像\n                        </div>\n                      );\n                    }\n                    const topMeta = surfaceImageInfo.find((info) => info.surface === \"top\");\n                    const bottomMeta = surfaceImageInfo.find((info) => info.surface === \"bottom\");\n                    const layout = buildOrientationLayout({\n                      orientation: imageOrientation,\n                      surfaceFilter,\n                      topMeta,\n                      bottomMeta,\n                      surfaceGap: imageOrientation === \"horizontal\" ? 0 : 40,\n                    });\n                    if (layout.surfaces.length === 0) {\n                      return (\n                        <div className=\"absolute inset-0 flex items-center justify-center text-xs text-muted-foreground\">\n                          无法构建图像布局，请检查表面配置\n                        </div>\n                      );\n                    }\n                    const viewerTileSize = Math.max(\n                      topMeta?.image_height ?? 0,\n                      bottomMeta?.image_height ?? 0,\n                      1024,\n                    );\n                    const defectWorldRects = plateDefects\n                      .map((defect) => {\n                        const surfaceLayout = layout.surfaces.find(\n                          (s) => s.surface === defect.surface,\n                        );\n                        if (!surfaceLayout) {\n                          return null;\n                        }\n                        const rect = convertDefectToWorldRect({\n                          surface: surfaceLayout,\n                          defect,\n                          orientation: imageOrientation,\n                        });\n                        if (!rect) {\n                          return null;\n                        }\n                        return { defect, surface: surfaceLayout, rect };\n                      })\n                      .filter(\n                        (\n                          item,\n                        ): item is {\n                          defect: Defect;\n                          surface: SurfaceLayout;\n                          rect: { x: number; y: number; width: number; height: number };\n                        } => item !== null,\n                      );\n                    const severityColor = (severity: Defect[\"severity\"]) => {\n                      switch (severity) {\n                        case \"high\":\n                          return \"#ef4444\";\n                        case \"medium\":\n                          return \"#f97316\";\n                        default:\n                          return \"#22c55e\";\n                      }\n                    };\n                    const renderTile = (\n                      ctx: CanvasRenderingContext2D,\n                      tile: Tile,\n                      tileSizeArg: number,\n                      scale: number,\n                    ) => {\n                      const surfaceLayout = pickSurfaceForTile(layout, tile);\n                      if (!surfaceLayout) {\n                        ctx.fillStyle = \"#f1f5f9\";\n                        ctx.fillRect(tile.x, tile.y, tile.width, tile.height);\n                        return;\n                      }\n                      const virtualTileSize = tileSizeArg * Math.pow(2, tile.level);\n                      const requestInfo = computeTileRequestInfo({\n                        surface: surfaceLayout,\n                        tile,\n                        orientation: imageOrientation,\n                        virtualTileSize,\n                      });\n                      if (!requestInfo) {\n                        ctx.fillStyle = \"#f1f5f9\";\n                        ctx.fillRect(tile.x, tile.y, tile.width, tile.height);\n                        return;\n                      }\n                      const cacheKey = `${imageOrientation}-${surfaceLayout.surface}-${seqNo}-${tile.level}-${requestInfo.tileX}-${requestInfo.tileY}-${tileSizeArg}`;\n                      const cached = tileImageCache.get(cacheKey);\n                      const url = getTileImageUrl({\n                        surface: surfaceLayout.surface,\n                        seqNo,\n                        level: tile.level,\n                        tileX: requestInfo.tileX,\n                        tileY: requestInfo.tileY,\n                        tileSize: tileSizeArg,\n                        fmt: \"JPEG\",\n                        orientation: imageOrientation,\n                      });\n                      if (cached && cached.complete) {\n                        ctx.drawImage(cached, tile.x, tile.y, tile.width, tile.height);\n                      } else {\n                        if (!tileImageLoading.has(cacheKey)) {\n                          tileImageLoading.add(cacheKey);\n                          const img = new Image();\n                          img.src = url;\n                          img.onload = () => {\n                            tileImageCache.set(cacheKey, img);\n                            tileImageLoading.delete(cacheKey);\n                          };\n                          img.onerror = () => {\n                            tileImageLoading.delete(cacheKey);\n                          };\n                        }\n                        ctx.fillStyle = \"#e2e8f0\";\n                        ctx.fillRect(tile.x, tile.y, tile.width, tile.height);\n                        ctx.strokeStyle = \"#94a3b8\";\n                        ctx.lineWidth = 1 / scale;\n                        ctx.strokeRect(tile.x, tile.y, tile.width, tile.height);\n                      }\n                      const defectsInTile = defectWorldRects.filter((item) => {\n                        const { rect, surface } = item;\n                        if (surface.surface !== surfaceLayout.surface) {\n                          return false;\n                        }\n                        return !(\n                          rect.x + rect.width < tile.x ||\n                          rect.x > tile.x + tile.width ||\n                          rect.y + rect.height < tile.y ||\n                          rect.y > tile.y + tile.height\n                        );\n                      });\n                      defectsInTile.forEach(({ defect, rect }) => {\n                        ctx.strokeStyle = severityColor(defect.severity);\n                        ctx.lineWidth =\n                          defect.id === selectedDefectId ? 3 / scale : 1.5 / scale;\n                        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);\n                        if (scale > 0.4) {\n                          ctx.save();\n                          ctx.translate(rect.x + 4, rect.y + 4);\n                          const labelScale = 1 / scale;\n                          ctx.scale(labelScale, labelScale);\n                          ctx.font = \"10px 'Consolas', sans-serif\";\n                          ctx.fillStyle = ctx.strokeStyle;\n                          ctx.fillText(defect.type, 0, 10);\n                          ctx.restore();\n                        }\n                      });\n                    };\n                    const renderOverlay = (\n                      ctx: CanvasRenderingContext2D,\n                      scale: number,\n                    ) => {\n                      layout.surfaces.forEach((surfaceLayout) => {\n                        const stroke =\n                          surfaceLayout.surface === \"top\"\n                            ? \"#0ea5e9\"\n                            : \"#f97316\";\n                        ctx.save();\n                        ctx.lineWidth = 3 / scale;\n                        ctx.strokeStyle = stroke;\n                        ctx.setLineDash([10 / scale, 6 / scale]);\n                        ctx.strokeRect(\n                          surfaceLayout.offsetX,\n                          surfaceLayout.offsetY,\n                          surfaceLayout.worldWidth,\n                          surfaceLayout.worldHeight,\n                        );\n                        ctx.setLineDash([]);\n                        ctx.translate(\n                          surfaceLayout.offsetX + 12 / scale,\n                          surfaceLayout.offsetY + 18 / scale,\n                        );\n                        const labelScale = 1 / scale;\n                        ctx.scale(labelScale, labelScale);\n                        ctx.font = \"bold 12px 'Consolas', sans-serif\";\n                        ctx.fillStyle = stroke;\n                        ctx.fillText(\n                          surfaceLayout.surface === \"top\"\n                            ? \"TOP SURFACE\"\n                            : \"BOTTOM SURFACE\",\n                          0,\n                          0,\n                        );\n                        ctx.restore();\n                      });\n                    };\n                    return (\n                      <LargeImageViewer\n                        imageWidth={layout.worldWidth}\n                        imageHeight={layout.worldHeight}\n                        tileSize={viewerTileSize}\n                        className=\"bg-slate-50\"\n                        fixedLevel={activeTileLevel}\n                        onPreferredLevelChange={setPreferredTileLevel}\n                        renderTile={renderTile}\n                        renderOverlay={renderOverlay}\n                        panMargin={200}\n                      />\n                    );"""
end_pos = end + len(end_marker)
text = text[:start] + replacement + text[end_pos:]
path.write_text(text, encoding="utf-8")
